# Story 3.4: Register Consistency Dimension

**Status:** ✅ APPROVED
**Parent Epic:** Content-Aware Analysis System (Epic 3.0) - New Dimensions
**Estimated Effort:** 2-3 days
**Dependencies:** Story 1.4.11 (Dimension Registry)
**Priority:** HIGH (Universal applicability across all content types)
**Target Version:** 1.5.0

---

## Story

As a **technical writer analyzing document quality**,
I want **the analyzer to detect inconsistent register/formality** (e.g., mixing "utilize" with "use", "individuals" with "people"),
so that **I can identify AI-like register mixing and maintain appropriate formality levels**.

---

## Acceptance Criteria

### AC1: Register Pair Detection
- [ ] Detects formal/informal synonym pairs within text
- [ ] Formal synonyms: utilize/use, individuals/people, ascertain/find out, commence/start, terminate/end, purchase/buy, assist/help, obtain/get, demonstrate/show, consequently/so
- [ ] Detects mixing within same document (both forms present)
- [ ] Returns count of inconsistent pairs detected

### AC2: Formality Scoring
- [ ] Calculates formality ratio: `formal_words / (formal_words + informal_words)`
- [ ] Consistent formal (ratio 0.80-1.00): EXCELLENT
- [ ] Consistent informal (ratio 0.00-0.20): EXCELLENT
- [ ] Mixed register (ratio 0.30-0.70): POOR (AI-like mixing)
- [ ] Borderline (ratio 0.20-0.30 or 0.70-0.80): NEEDS WORK

### AC3: Content-Aware Assessment
- [ ] Academic/Business: Formal register expected (ratio 0.80+ = EXCELLENT)
- [ ] Blog/Creative: Informal register expected (ratio 0.20- = EXCELLENT)
- [ ] Technical Book: Moderate formality OK (ratio 0.40-0.60 = GOOD)
- [ ] Professional Bio: Formal register expected (ratio 0.80+ = EXCELLENT)
- [ ] Personal Statement: Informal-moderate OK (ratio 0.20-0.50 = GOOD)

### AC4: Self-Registration
- [ ] Dimension auto-registers via `@register_dimension` decorator
- [ ] Included in `balanced` and `full` dimension profiles
- [ ] Not included in `fast` profile (requires synonym matching)

### AC5: Report Output
- [ ] Shows formality ratio and assessment
- [ ] Lists inconsistent pairs detected: `"utilize" (3) / "use" (5) - MIXED`
- [ ] Shows density: `inconsistent_pairs per 1k words`
- [ ] Provides actionable guidance: "Choose consistent register: either formal or informal"

### AC6: Performance
- [ ] Completes analysis in <0.05s for 10,000 word documents
- [ ] Memory usage <500KB additional
- [ ] No external API calls (lexicon-based)

### AC7: Testing Coverage
- [ ] Unit tests achieve ≥85% coverage
- [ ] Test all formal/informal pairs detected
- [ ] Test formality ratio calculation
- [ ] Test content-aware assessments
- [ ] Test edge cases (all formal, all informal, perfectly mixed)

---

## Tasks/Subtasks

### Task 1: Core Dimension Implementation (1 day)
- [ ] Create `writescore/dimensions/register_consistency.py`
- [ ] Implement `RegisterConsistencyDimension(BaseDimensionStrategy)`
- [ ] Define formal/informal synonym pairs lexicon
- [ ] Implement `@register_dimension` decorator
- [ ] Add to default dimension profiles (balanced, full)

### Task 2: Register Analysis Logic (0.5 days)
- [ ] Implement `detect_register_pairs(text) -> List[Tuple[str, int, int]]`
  - Returns: `[(formal_word, formal_count, informal_count), ...]`
- [ ] Implement `calculate_formality_ratio(pairs) -> float`
  - Formula: `sum(formal_counts) / sum(formal_counts + informal_counts)`
- [ ] Implement `detect_mixing_patterns(pairs) -> List[str]`
  - Identifies specific inconsistent pairs

### Task 3: Content-Aware Thresholds (0.25 days)
- [ ] Define register thresholds in CONTENT_TYPE_THRESHOLDS
- [ ] Academic: formal ratio 0.80+ = EXCELLENT
- [ ] Blog: informal ratio 0.20- = EXCELLENT
- [ ] Technical Book: moderate 0.40-0.60 = GOOD
- [ ] Integrate with content type scoring

### Task 4: Report Formatting (0.25 days)
- [ ] Format dimension score output
- [ ] List inconsistent pairs with counts
- [ ] Show formality ratio and density
- [ ] Provide actionable recommendations

### Task 5: Testing (0.5 days)
- [ ] Unit tests for synonym pair detection
- [ ] Unit tests for formality ratio calculation
- [ ] Content-aware assessment tests
- [ ] Edge case tests (monoregister, perfect mixing)
- [ ] Performance benchmarks

### Task 6: Documentation (0.25 days)
- [ ] Update CHANGELOG.md
- [ ] Add dimension to README
- [ ] Document formal/informal pairs lexicon
- [ ] Provide usage examples

---

## Dev Notes

### Background Context

**Problem**: AI systems often mix formal and informal registers inappropriately:
- "We need to *utilize* best practices when you *use* this tool"
- "The *individuals* in the study were *people* from diverse backgrounds"
- "Please *commence* the process and *start* the analysis"

Human writers typically maintain consistent register throughout a document. Register mixing is a strong AI signal.

**Research Foundation**:
- Formality level is a core dimension of register variation (Biber et al.)
- AI systems trained on diverse corpora exhibit register mixing
- Humans self-correct for register consistency during revision
- Academic writing: 85%+ formal register consistency
- Blog writing: 80%+ informal register consistency

**Content Type Expectations**:

| Content Type | Expected Register | Formality Ratio | Assessment |
|--------------|-------------------|-----------------|------------|
| Academic | Formal | 0.80-1.00 | EXCELLENT |
| Business | Formal | 0.70-1.00 | EXCELLENT |
| Professional Bio | Formal | 0.80-1.00 | EXCELLENT |
| Technical Docs | Formal-Moderate | 0.60-0.90 | GOOD |
| Technical Book | Moderate | 0.40-0.60 | GOOD |
| Blog | Informal | 0.00-0.30 | EXCELLENT |
| Personal Statement | Informal-Moderate | 0.20-0.50 | GOOD |
| Creative | Informal | 0.00-0.30 | EXCELLENT |
| News | Formal-Moderate | 0.60-0.80 | GOOD |

### Implementation Strategy

**1. Formal/Informal Synonym Pairs Lexicon**
```python
# writescore/dimensions/register_consistency.py

REGISTER_PAIRS = {
    # (formal, informal)
    'utilize': 'use',
    'utilizes': 'uses',
    'utilized': 'used',
    'utilizing': 'using',
    'individuals': 'people',
    'individual': 'person',
    'ascertain': 'find out',
    'commence': 'start',
    'commences': 'starts',
    'commenced': 'started',
    'commencing': 'starting',
    'terminate': 'end',
    'terminates': 'ends',
    'terminated': 'ended',
    'terminating': 'ending',
    'purchase': 'buy',
    'purchases': 'buys',
    'purchased': 'bought',
    'purchasing': 'buying',
    'assist': 'help',
    'assists': 'helps',
    'assisted': 'helped',
    'assisting': 'helping',
    'obtain': 'get',
    'obtains': 'gets',
    'obtained': 'got',
    'obtaining': 'getting',
    'demonstrate': 'show',
    'demonstrates': 'shows',
    'demonstrated': 'showed',
    'demonstrating': 'showing',
    'consequently': 'so',
    'therefore': 'so',
    'thus': 'so',
    'furthermore': 'also',
    'moreover': 'also',
    'additionally': 'also',
    'sufficient': 'enough',
    'insufficient': 'not enough',
    'attempt': 'try',
    'attempts': 'tries',
    'attempted': 'tried',
    'attempting': 'trying',
    'comprehend': 'understand',
    'comprehends': 'understands',
    'comprehended': 'understood',
    'comprehending': 'understanding',
    'endeavor': 'try',
    'endeavors': 'tries',
    'endeavored': 'tried',
    'endeavoring': 'trying',
    'facilitate': 'help',
    'facilitates': 'helps',
    'facilitated': 'helped',
    'facilitating': 'helping',
    'implement': 'do',
    'implements': 'does',
    'implemented': 'did',
    'implementing': 'doing',
}

# Create reverse mapping (informal → formal)
INFORMAL_TO_FORMAL = {v: k for k, v in REGISTER_PAIRS.items()}

# Create bidirectional pair groupings
REGISTER_PAIR_GROUPS = {}
for formal, informal in REGISTER_PAIRS.items():
    # Normalize to base form for grouping
    formal_base = formal.split()[0]  # Handle multi-word like "find out"
    if formal_base not in REGISTER_PAIR_GROUPS:
        REGISTER_PAIR_GROUPS[formal_base] = {'formal': set(), 'informal': set()}

    REGISTER_PAIR_GROUPS[formal_base]['formal'].add(formal)
    REGISTER_PAIR_GROUPS[formal_base]['informal'].add(informal)
```

**2. Register Detection Logic**
```python
@register_dimension
class RegisterConsistencyDimension(BaseDimensionStrategy):
    """Detects inconsistent register/formality mixing"""

    dimension_name = "register_consistency"

    def analyze(self, text: str, content_type: Optional[str] = None) -> Dict[str, Any]:
        """Detect register mixing patterns"""
        words = self._tokenize(text)
        word_count = len(words)

        # Detect formal/informal pair usage
        pair_usage = self._detect_register_pairs(words)

        # Calculate formality ratio
        formality_ratio = self._calculate_formality_ratio(pair_usage)

        # Identify inconsistent pairs (both forms present)
        inconsistent_pairs = self._find_inconsistent_pairs(pair_usage)

        # Calculate density
        density = (len(inconsistent_pairs) / word_count) * 1000 if word_count > 0 else 0

        # Content-aware assessment
        assessment = self._assess_register(
            formality_ratio,
            len(inconsistent_pairs),
            content_type
        )

        return {
            'formality_ratio': formality_ratio,
            'inconsistent_pairs': inconsistent_pairs,
            'density': density,
            'assessment': assessment,
            'pair_usage': pair_usage,
        }

    def _detect_register_pairs(self, words: List[str]) -> Dict[str, Dict[str, int]]:
        """Count formal/informal usage for each pair group"""
        pair_usage = {}

        words_lower = [w.lower() for w in words]

        for base_form, pair_group in REGISTER_PAIR_GROUPS.items():
            formal_count = 0
            informal_count = 0

            for formal_variant in pair_group['formal']:
                formal_count += words_lower.count(formal_variant.lower())

            for informal_variant in pair_group['informal']:
                informal_count += words_lower.count(informal_variant.lower())

            if formal_count > 0 or informal_count > 0:
                pair_usage[base_form] = {
                    'formal': formal_count,
                    'informal': informal_count,
                    'formal_examples': list(pair_group['formal']),
                    'informal_examples': list(pair_group['informal']),
                }

        return pair_usage

    def _calculate_formality_ratio(self, pair_usage: Dict) -> float:
        """Calculate overall formality: formal / (formal + informal)"""
        total_formal = sum(p['formal'] for p in pair_usage.values())
        total_informal = sum(p['informal'] for p in pair_usage.values())
        total = total_formal + total_informal

        if total == 0:
            return 0.5  # Neutral if no register pairs detected

        return total_formal / total

    def _find_inconsistent_pairs(self, pair_usage: Dict) -> List[Dict]:
        """Identify pairs where both formal and informal forms are used"""
        inconsistent = []

        for base_form, usage in pair_usage.items():
            if usage['formal'] > 0 and usage['informal'] > 0:
                inconsistent.append({
                    'base': base_form,
                    'formal_count': usage['formal'],
                    'informal_count': usage['informal'],
                    'formal_examples': usage['formal_examples'],
                    'informal_examples': usage['informal_examples'],
                })

        return inconsistent

    def _assess_register(
        self,
        formality_ratio: float,
        inconsistent_count: int,
        content_type: Optional[str]
    ) -> str:
        """Assess register consistency based on content type"""

        # Generic assessment (no content type)
        if content_type is None:
            if inconsistent_count == 0:
                return 'EXCELLENT'  # Consistent register
            elif formality_ratio < 0.20 or formality_ratio > 0.80:
                return 'GOOD'  # Mostly consistent, minor mixing
            elif 0.30 <= formality_ratio <= 0.70:
                return 'POOR'  # Significant register mixing (AI-like)
            else:
                return 'NEEDS WORK'  # Borderline

        # Content-aware assessment
        thresholds = get_content_thresholds(
            content_type,
            'register_consistency',
            'formality_ratio'
        )

        if thresholds:
            if formality_ratio >= thresholds['EXCELLENT'][0] and formality_ratio <= thresholds['EXCELLENT'][1]:
                return 'EXCELLENT' if inconsistent_count == 0 else 'GOOD'
            elif formality_ratio >= thresholds['GOOD'][0] and formality_ratio <= thresholds['GOOD'][1]:
                return 'GOOD' if inconsistent_count <= 2 else 'NEEDS WORK'
            else:
                return 'POOR'

        # Fallback
        return 'NEEDS WORK'

    def format_results(self, results: Dict[str, Any]) -> str:
        """Format dimension results for report"""
        output = []

        formality_ratio = results['formality_ratio']
        inconsistent_pairs = results['inconsistent_pairs']
        density = results['density']

        output.append(f"Formality Ratio: {formality_ratio:.2f} (0=informal, 1=formal)")

        if inconsistent_pairs:
            output.append(f"\nInconsistent Pairs Detected: {len(inconsistent_pairs)} ({density:.1f} per 1k words)")
            for pair in inconsistent_pairs:
                output.append(
                    f"  • {pair['formal_examples'][0]} ({pair['formal_count']}) / "
                    f"{pair['informal_examples'][0]} ({pair['informal_count']}) - MIXED"
                )

            output.append("\n→ ACTION: Choose consistent register throughout document")
        else:
            output.append("\n✓ Consistent register (no formal/informal mixing)")

        return "\n".join(output)
```

**3. Content Type Thresholds**
```python
# Add to CONTENT_TYPE_THRESHOLDS in content_type_config.py

'academic': {
    'register_consistency': {
        'formality_ratio': {
            'EXCELLENT': (0.80, 1.00),  # Formal register expected
            'GOOD': (0.70, 0.90),
            'NEEDS_WORK': (0.60, 0.70),
            'POOR': (0.00, 0.60),  # Informal inappropriate
        }
    }
},
'blog': {
    'register_consistency': {
        'formality_ratio': {
            'EXCELLENT': (0.00, 0.20),  # Informal register expected
            'GOOD': (0.00, 0.30),
            'NEEDS_WORK': (0.30, 0.40),
            'POOR': (0.40, 1.00),  # Formal inappropriate
        }
    }
},
'technical_book': {
    'register_consistency': {
        'formality_ratio': {
            'EXCELLENT': (0.40, 0.60),  # Moderate formality OK
            'GOOD': (0.30, 0.70),
            'NEEDS_WORK': (0.20, 0.30),
            'POOR': (0.00, 0.20),  # Too informal for technical content
        }
    }
},
```

**4. Example Output**
```
Register Consistency: POOR (Formality: 0.55)

Inconsistent Pairs Detected: 3 (5.2 per 1k words)
  • utilize (4) / use (7) - MIXED
  • individuals (2) / people (5) - MIXED
  • commence (1) / start (3) - MIXED

→ ACTION: Choose consistent register throughout document
  Either use formal terms (utilize, individuals, commence) OR
  informal terms (use, people, start), but not both
```

### Relevant Source Tree

```
writescore/
├── dimensions/
│   └── register_consistency.py       # [NEW] Register consistency dimension
├── core/
│   └── content_type_config.py        # [MODIFY] Add register thresholds
└── tests/
    └── unit/
        └── dimensions/
            └── test_register_consistency.py  # [NEW] 85%+ coverage
```

### Performance Requirements

- **Analysis Time**: <0.05s for 10,000 word documents
- **Memory**: <500KB for lexicon storage
- **No External APIs**: Pure lexicon-based matching

### Testing Requirements

**Unit Tests** (≥85% coverage):
```python
def test_detect_formal_informal_mixing():
    """Detect when both formal and informal forms are used"""
    text = "We need to utilize best practices when you use this tool."

    dimension = RegisterConsistencyDimension()
    results = dimension.analyze(text)

    assert len(results['inconsistent_pairs']) == 1
    assert results['inconsistent_pairs'][0]['base'] == 'utilize'
    assert results['assessment'] in ['POOR', 'NEEDS WORK']

def test_consistent_formal_register():
    """All formal terms should score EXCELLENT"""
    text = "We must utilize best practices and assist individuals to obtain optimal results."

    dimension = RegisterConsistencyDimension()
    results = dimension.analyze(text)

    assert results['formality_ratio'] >= 0.95
    assert len(results['inconsistent_pairs']) == 0
    assert results['assessment'] == 'EXCELLENT'

def test_consistent_informal_register():
    """All informal terms should score EXCELLENT"""
    text = "We need to use best practices and help people to get good results."

    dimension = RegisterConsistencyDimension()
    results = dimension.analyze(text)

    assert results['formality_ratio'] <= 0.05
    assert len(results['inconsistent_pairs']) == 0
    assert results['assessment'] == 'EXCELLENT'

def test_content_aware_academic_formality():
    """Academic content expects formal register"""
    text = "We utilize advanced methodologies to assist researchers."

    dimension = RegisterConsistencyDimension()
    results = dimension.analyze(text, content_type='academic')

    assert results['assessment'] == 'EXCELLENT'  # Formal appropriate for academic

def test_content_aware_blog_informality():
    """Blog content expects informal register"""
    text = "I want to use simple tools to help people get started."

    dimension = RegisterConsistencyDimension()
    results = dimension.analyze(text, content_type='blog')

    assert results['assessment'] == 'EXCELLENT'  # Informal appropriate for blog
```

### Documentation Requirements

**CHANGELOG.md**:
```markdown
## [1.5.0] - 2025-XX-XX

### Added
- **Register Consistency Dimension** (Story 3.4): Detects formal/informal register mixing
  - Identifies synonym pairs: utilize/use, individuals/people, commence/start, etc.
  - Calculates formality ratio (0=informal, 1=formal)
  - Content-aware assessment (academic expects formal, blog expects informal)
  - Reports inconsistent pairs with counts and actionable guidance
  - Universal applicability across all content types
```

**README.md**:
```markdown
## Register Consistency Dimension

Detects inappropriate mixing of formal and informal registers:

```bash
python analyze_ai_patterns.py document.md --profile full

# Output:
# Register Consistency: POOR (Formality: 0.55)
#
# Inconsistent Pairs Detected: 3 (5.2 per 1k words)
#   • utilize (4) / use (7) - MIXED
#   • individuals (2) / people (5) - MIXED
#
# → ACTION: Choose consistent register throughout
```

Human writers maintain consistent formality. Register mixing is a strong AI signal.
```

---

## QA Results

### Test Coverage
- [ ] Unit tests: ___% (Target: ≥85%)
- [ ] Lexicon coverage: 40+ formal/informal pairs
- [ ] Content-aware tests: 9/9 content types

### Performance Benchmarks
- [ ] Analysis time (10k words): ___ms (Target: <50ms)
- [ ] Memory usage: ___KB (Target: <500KB)

### Manual Validation
- [ ] Tested with mixed-register documents
- [ ] Verified consistent formal = EXCELLENT
- [ ] Verified consistent informal = EXCELLENT
- [ ] Confirmed content-aware assessments

---

## Change Log

| Date | Author | Change | Status |
|------|--------|--------|--------|
| 2025-01-XX | jmagady | Initial story creation | APPROVED |
