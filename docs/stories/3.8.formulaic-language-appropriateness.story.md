# Story 3.8: Formulaic Language Appropriateness (Context-Dependent Scoring)

**Status:** ✅ APPROVED
**Parent Epic:** Content-Aware Analysis System (Epic 3.0) - New Dimensions
**Estimated Effort:** 2-3 days
**Dependencies:** Story 3.3 (Content-Aware Scoring Thresholds)
**Priority:** HIGH (Demonstrates context-dependent scoring paradigm)
**Target Version:** 1.5.0

---

## Story

As a **technical writer analyzing different content types**,
I want **formulaic language to be scored appropriately by context** (EXCELLENT for technical docs, POOR for creative writing),
so that **the same formulaic pattern receives opposite assessments based on genre appropriateness**.

---

## Acceptance Criteria

### AC1: Formulaic Phrase Detection
- [ ] Detects repetitive transitional phrases (already in transition_marker dimension)
- [ ] Detects formulaic heading patterns (numbered steps, "Introduction", "Conclusion")
- [ ] Detects boilerplate language ("It's important to note", "As previously mentioned")
- [ ] Calculates formulaic density: `formulaic_phrases / total_sentences × 100`

### AC2: Context-Dependent Assessment
- [ ] **Technical Docs**: Formulaic = EXCELLENT (0-5 instances = scannable/findable)
  - "Step 1:", "Next, you will", "Note:" = *appropriate* for instructions
- [ ] **Technical Book**: Formulaic = POOR (>10 instances = repetitive over 300 pages)
  - "As we saw in Chapter X" every chapter = *boring*
- [ ] **Creative Writing**: Formulaic = POOR (any formulaic language = *robotic*)
  - "Firstly", "In conclusion" = *inappropriate* for narrative
- [ ] **Academic**: Formulaic transitions OK (5-10 instances = logical scaffolding)
  - "Furthermore", "Therefore" = *appropriate* for argumentation

### AC3: Integrated with Structure Dimension
- [ ] Extends existing structure dimension with content-aware scoring
- [ ] Uses formulaic transition count from transition_marker dimension
- [ ] Adds heading pattern analysis
- [ ] Adds boilerplate detection

### AC4: Opposite Scoring for Same Metric
- [ ] Technical docs with 5 formulaic phrases: EXCELLENT (findability)
- [ ] Technical book with 5 formulaic phrases: NEEDS WORK (repetitive)
- [ ] Creative writing with 5 formulaic phrases: POOR (robotic)
- [ ] Same density, three different assessments

### AC5: Report Output
- [ ] Shows formulaic density and content-type-specific assessment
- [ ] Lists detected formulaic phrases
- [ ] Explains why formulaic is appropriate/inappropriate for genre
- [ ] Provides genre-specific actionable guidance

### AC6: Performance & Testing
- [ ] Completes analysis in <0.02s (extends existing structure analysis)
- [ ] Memory <200KB (phrase pattern matching)
- [ ] Unit tests achieve ≥85% coverage
- [ ] Tests same metric produces opposite assessments

---

## Tasks/Subtasks

### Task 1: Formulaic Phrase Lexicon (0.5 days)
- [ ] Define formulaic transition phrases (extends transition_marker)
- [ ] Define formulaic heading patterns (numbered steps, standard sections)
- [ ] Define boilerplate phrases ("It's important to note", "Keep in mind")
- [ ] Create `FORMULAIC_PATTERNS` configuration

### Task 2: Detection Logic (0.5 days)
- [ ] Implement `detect_formulaic_transitions(text) -> List[str]`
- [ ] Implement `detect_formulaic_headings(text) -> List[str]`
- [ ] Implement `detect_boilerplate(text) -> List[str]`
- [ ] Calculate overall formulaic density

### Task 3: Context-Dependent Scoring (0.5 days)
- [ ] Define content-type-specific thresholds in CONTENT_TYPE_THRESHOLDS
- [ ] Technical docs: 0-5 formulaic = EXCELLENT
- [ ] Technical book: 0-3 = GOOD, >10 = POOR
- [ ] Creative: 0 = EXCELLENT, >3 = POOR
- [ ] Implement assessment logic with content type

### Task 4: Structure Dimension Extension (0.5 days)
- [ ] Extend structure dimension with formulaic appropriateness
- [ ] Integrate formulaic density into structure scoring
- [ ] Add content-aware assessment
- [ ] Maintain backward compatibility

### Task 5: Testing (0.5 days)
- [ ] Unit tests for formulaic phrase detection
- [ ] Unit tests for context-dependent scoring
- [ ] Test same density produces opposite assessments
- [ ] Test all content types
- [ ] Performance benchmarks

### Task 6: Documentation (0.25 days)
- [ ] Update CHANGELOG.md
- [ ] Document context-dependent scoring paradigm
- [ ] Provide examples showing opposite assessments
- [ ] Add usage examples

---

## Dev Notes

### Background Context

**Problem**: Current analyzer penalizes *all* formulaic language uniformly. This causes:
- Technical docs wrongly penalized for "Step 1, Step 2" (actually improves findability)
- Creative writing not penalized enough for "In conclusion" (inappropriate for narrative)
- Technical books score same as technical docs despite 300-page repetition being worse

**Solution**: Context-dependent scoring where the same metric value receives different assessments based on genre appropriateness.

**Key Insight**: Formulaic language appropriateness is **inversely correlated** across genres:
- Technical docs: More formulaic = BETTER (scanability)
- Creative writing: More formulaic = WORSE (robotic)
- Technical books: Moderate formulaic = POOR (boring over 300 pages)

**Examples**:

| Formulaic Density | Technical Docs | Technical Book | Creative |
|-------------------|----------------|----------------|----------|
| 0 instances | NEEDS WORK (unclear) | EXCELLENT (varied) | EXCELLENT (natural) |
| 3 instances | EXCELLENT (scannable) | GOOD (acceptable) | POOR (robotic) |
| 10 instances | EXCELLENT (very clear) | POOR (repetitive) | POOR (mechanical) |

### Implementation Strategy

**1. Formulaic Pattern Lexicon**
```python
# writescore/dimensions/structure.py (EXTEND)

FORMULAIC_TRANSITIONS = [
    'firstly', 'secondly', 'thirdly', 'finally',
    'in conclusion', 'to summarize', 'in summary',
    'as mentioned above', 'as previously mentioned', 'as we saw',
    'it is important to note', 'it should be noted',
    'keep in mind', 'bear in mind', 'take note',
    'moving on to', 'turning to', 'next we will',
]

FORMULAIC_HEADINGS = [
    r'^(Step|Part|Section|Chapter)\s+\d+',  # Numbered sections
    r'^(Introduction|Conclusion|Summary|Background|Methodology)$',  # Standard sections
    r'^(Getting Started|Prerequisites|Installation|Configuration)$',  # Technical doc patterns
]

BOILERPLATE_PHRASES = [
    'it\'s important to note that',
    'it should be noted that',
    'it\'s worth mentioning that',
    'as previously mentioned',
    'as we discussed earlier',
    'keep in mind that',
    'bear in mind that',
    'don\'t forget that',
]

class StructureDimension(BaseDimensionStrategy):
    """Extended with formulaic appropriateness scoring"""

    def analyze(self, text: str, content_type: Optional[str] = None) -> Dict[str, Any]:
        """Analyze structure with content-aware formulaic scoring"""

        # ... existing structure analysis ...

        # Detect formulaic patterns
        formulaic_transitions = self._detect_formulaic_transitions(text)
        formulaic_headings = self._detect_formulaic_headings(text)
        boilerplate = self._detect_boilerplate(text)

        total_formulaic = len(formulaic_transitions) + len(formulaic_headings) + len(boilerplate)
        sentence_count = len(self._split_sentences(text))
        formulaic_density = (total_formulaic / sentence_count) * 100 if sentence_count > 0 else 0

        # Content-aware assessment of formulaic language
        formulaic_assessment = self._assess_formulaic_appropriateness(
            total_formulaic,
            formulaic_density,
            content_type
        )

        return {
            # ... existing metrics ...
            'formulaic_count': total_formulaic,
            'formulaic_density': formulaic_density,
            'formulaic_transitions': formulaic_transitions,
            'formulaic_headings': formulaic_headings,
            'boilerplate_phrases': boilerplate,
            'formulaic_assessment': formulaic_assessment,
        }

    def _detect_formulaic_transitions(self, text: str) -> List[str]:
        """Detect formulaic transition phrases"""
        sentences = self._split_sentences(text)
        detected = []

        for sentence in sentences:
            sentence_lower = sentence.lower()
            for pattern in FORMULAIC_TRANSITIONS:
                if pattern in sentence_lower:
                    detected.append(pattern)

        return detected

    def _detect_formulaic_headings(self, text: str) -> List[str]:
        """Detect formulaic heading patterns"""
        headings = re.findall(r'^#+\s+(.+)$', text, re.MULTILINE)
        detected = []

        for heading in headings:
            for pattern in FORMULAIC_HEADINGS:
                if re.match(pattern, heading, re.IGNORECASE):
                    detected.append(heading)
                    break

        return detected

    def _detect_boilerplate(self, text: str) -> List[str]:
        """Detect boilerplate phrases"""
        text_lower = text.lower()
        detected = []

        for phrase in BOILERPLATE_PHRASES:
            if phrase in text_lower:
                detected.append(phrase)

        return detected

    def _assess_formulaic_appropriateness(
        self,
        formulaic_count: int,
        formulaic_density: float,
        content_type: Optional[str]
    ) -> str:
        """Context-dependent assessment of formulaic language"""

        if content_type == 'technical_docs':
            # Formulaic = GOOD (scanability, findability)
            if formulaic_count <= 5:
                return 'EXCELLENT'  # Clear structure
            elif formulaic_count <= 10:
                return 'EXCELLENT'  # Very scannable
            else:
                return 'GOOD'  # Might be redundant but acceptable

        elif content_type == 'technical_book':
            # Formulaic = BAD (repetitive over 300 pages)
            if formulaic_count <= 3:
                return 'GOOD'  # Acceptable variation
            elif formulaic_count <= 10:
                return 'NEEDS WORK'  # Getting repetitive
            else:
                return 'POOR'  # Boring/mechanical over long form

        elif content_type == 'creative':
            # Formulaic = BAD (robotic, kills narrative flow)
            if formulaic_count == 0:
                return 'EXCELLENT'  # Natural flow
            elif formulaic_count <= 2:
                return 'NEEDS WORK'  # Slightly mechanical
            else:
                return 'POOR'  # Robotic narrative

        elif content_type == 'academic':
            # Formulaic transitions OK (logical scaffolding)
            if 3 <= formulaic_count <= 8:
                return 'GOOD'  # Appropriate signposting
            elif formulaic_count < 3:
                return 'NEEDS WORK'  # Unclear argumentation
            else:
                return 'NEEDS WORK'  # Over-signaled

        elif content_type == 'blog':
            # Some formulaic OK (listicles), but not too much
            if formulaic_count <= 4:
                return 'GOOD'  # Casual structure
            elif formulaic_count <= 8:
                return 'NEEDS WORK'  # Getting mechanical
            else:
                return 'POOR'  # Too formulaic for conversational

        else:
            # Generic: moderate formulaic = NEEDS WORK
            if formulaic_count <= 3:
                return 'GOOD'
            elif formulaic_count <= 8:
                return 'NEEDS WORK'
            else:
                return 'POOR'

    def format_results(self, results: Dict[str, Any]) -> str:
        """Format structure results with formulaic assessment"""
        output = []

        # ... existing structure output ...

        formulaic_count = results.get('formulaic_count', 0)
        formulaic_assessment = results.get('formulaic_assessment', 'N/A')

        output.append(f"\nFormulaic Language: {formulaic_assessment} ({formulaic_count} instances)")

        if results.get('formulaic_transitions'):
            output.append(f"  Transitions: {', '.join(results['formulaic_transitions'][:3])}")

        if results.get('formulaic_headings'):
            output.append(f"  Headings: {', '.join(results['formulaic_headings'][:3])}")

        # Context-specific guidance
        content_type = results.get('content_type')
        if content_type == 'technical_docs' and formulaic_assessment == 'EXCELLENT':
            output.append("  ✓ Formulaic structure appropriate for scanability")
        elif content_type == 'technical_book' and formulaic_count > 10:
            output.append("  → ACTION: Vary transitions to avoid repetition over 300 pages")
        elif content_type == 'creative' and formulaic_count > 0:
            output.append("  → ACTION: Remove formulaic transitions for natural narrative flow")

        return "\n".join(output)
```

**2. Content Type Thresholds**
```python
# Add to CONTENT_TYPE_THRESHOLDS in content_type_config.py

'technical_docs': {
    'structure': {
        'formulaic_count': {
            'EXCELLENT': (0, 10),   # Formulaic = good for findability
            'GOOD': (0, 15),
            'NEEDS_WORK': (15, 20),
            'POOR': (20, 100),
        }
    }
},
'technical_book': {
    'structure': {
        'formulaic_count': {
            'EXCELLENT': (0, 2),    # Minimal formulaic = varied
            'GOOD': (0, 3),
            'NEEDS_WORK': (3, 10),
            'POOR': (10, 100),      # Formulaic = boring over 300 pages
        }
    }
},
'creative': {
    'structure': {
        'formulaic_count': {
            'EXCELLENT': (0, 0),    # Zero formulaic = natural
            'GOOD': (0, 1),
            'NEEDS_WORK': (1, 3),
            'POOR': (3, 100),       # Formulaic = robotic narrative
        }
    }
},
'academic': {
    'structure': {
        'formulaic_count': {
            'EXCELLENT': (3, 8),    # Moderate formulaic = signposting
            'GOOD': (2, 10),
            'NEEDS_WORK': (0, 2),   # Too few = unclear
            'POOR': (15, 100),      # Too many = over-signaled
        }
    }
},
```

**3. Example Output Demonstrating Opposite Scoring**

**Technical Documentation (5 formulaic phrases)**:
```
Structure: EXCELLENT (Formulaic: 5 instances)

Formulaic Language: EXCELLENT (5 instances)
  Transitions: Step 1, Next, Finally
  Headings: Introduction, Prerequisites, Installation

✓ Formulaic structure appropriate for scanability
```

**Technical Book (5 formulaic phrases)**:
```
Structure: NEEDS WORK (Formulaic: 5 instances)

Formulaic Language: NEEDS WORK (5 instances)
  Transitions: As we saw in Chapter 3, As mentioned above, Moving on to

→ ACTION: Vary transitions to avoid repetition over 300 pages
  Instead of "As we saw in Chapter X" every time, use varied references
```

**Creative Writing (5 formulaic phrases)**:
```
Structure: POOR (Formulaic: 5 instances)

Formulaic Language: POOR (5 instances)
  Transitions: Firstly, Secondly, In conclusion

→ ACTION: Remove formulaic transitions for natural narrative flow
  Replace "Firstly" with narrative progression: "The morning started..."
```

### Performance Requirements

- **Analysis Time**: <0.02s (extends existing structure analysis)
- **Memory**: <200KB for pattern matching
- **No Additional Dependencies**: Pure regex/string matching

### Testing Requirements

**Unit Tests** (≥85% coverage):
```python
def test_technical_docs_formulaic_excellent():
    """Technical docs: 5 formulaic phrases = EXCELLENT"""
    text = """
    # Introduction
    Step 1: Install the package.
    Next, configure the settings.
    Finally, run the application.
    """

    dimension = StructureDimension()
    results = dimension.analyze(text, content_type='technical_docs')

    assert results['formulaic_assessment'] == 'EXCELLENT'

def test_technical_book_formulaic_poor():
    """Technical book: 5 formulaic phrases = NEEDS WORK"""
    text = """
    As we saw in Chapter 3, the system works well.
    As mentioned above, configuration is important.
    Moving on to the next topic...
    """

    dimension = StructureDimension()
    results = dimension.analyze(text, content_type='technical_book')

    assert results['formulaic_assessment'] in ['NEEDS WORK', 'POOR']

def test_creative_formulaic_poor():
    """Creative: 5 formulaic phrases = POOR"""
    text = """
    Firstly, he walked into the room.
    Secondly, he noticed the painting.
    In conclusion, it was a strange day.
    """

    dimension = StructureDimension()
    results = dimension.analyze(text, content_type='creative')

    assert results['formulaic_assessment'] == 'POOR'

def test_same_count_opposite_assessments():
    """Same formulaic count produces opposite assessments"""
    formulaic_text = "Step 1: Do this. Next, do that. Finally, finish."

    dimension = StructureDimension()

    # Technical docs: EXCELLENT
    docs_result = dimension.analyze(formulaic_text, content_type='technical_docs')
    assert docs_result['formulaic_assessment'] == 'EXCELLENT'

    # Creative: POOR
    creative_result = dimension.analyze(formulaic_text, content_type='creative')
    assert creative_result['formulaic_assessment'] == 'POOR'
```

### Documentation Requirements

**CHANGELOG.md**:
```markdown
## [1.5.0] - 2025-XX-XX

### Added
- **Formulaic Language Appropriateness** (Story 3.8): Context-dependent scoring paradigm
  - Same formulaic density produces opposite assessments by genre
  - Technical docs: formulaic = EXCELLENT (scanability)
  - Technical books: formulaic = POOR (repetitive over 300 pages)
  - Creative writing: formulaic = POOR (robotic narrative)
  - Demonstrates content-aware scoring system in action
  - Detects formulaic transitions, headings, and boilerplate phrases
```

**README.md**:
```markdown
## Context-Dependent Scoring: Formulaic Language

The analyzer scores the same patterns differently based on genre appropriateness:

```bash
# Technical documentation (5 formulaic phrases)
python analyze_ai_patterns.py api-docs.md --content-type technical_docs
# Output: Formulaic Language: EXCELLENT (appropriate for scanability)

# Technical book (5 formulaic phrases)
python analyze_ai_patterns.py chapter-01.md --content-type technical_book
# Output: Formulaic Language: NEEDS WORK (repetitive over 300 pages)

# Creative writing (5 formulaic phrases)
python analyze_ai_patterns.py story.md --content-type creative
# Output: Formulaic Language: POOR (robotic narrative)
```

**Same metric, three different assessments.** This is the power of content-aware scoring.
```

---

## QA Results

### Test Coverage
- [ ] Unit tests: ___% (Target: ≥85%)
- [ ] Opposite assessment tests: Pass
- [ ] All content types tested: 9/9

### Performance Benchmarks
- [ ] Analysis time: ___ms (Target: <20ms)
- [ ] Memory usage: ___KB (Target: <200KB)

---

## Change Log

| Date | Author | Change | Status |
|------|--------|--------|--------|
| 2025-01-XX | jmagady | Initial story creation | APPROVED |
